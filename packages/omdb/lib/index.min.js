// ==UserScript==
// @author       Davide <iFelix18@protonmail.com>
// @namespace    https://github.com/iFelix18
// @exclude      *
// ==UserLibrary==
// @name         @ifelix18/omdb
// @description  OMDb API for my userscripts
// @copyright    2019, Davide (https://github.com/iFelix18)
// @license      MIT
// @version      3.1.0
// @homepage     https://github.com/iFelix18/Userscripts/tree/master/packages/omdb#readme
// @homepageURL  https://github.com/iFelix18/Userscripts/tree/master/packages/omdb#readme
// @supportURL   https://github.com/iFelix18/Userscripts/issues
// ==/UserLibrary==
// ==/UserScript==
this.OMDb=function(){const e={"/id":{method:"GET",optional:["plot","tomatoes","type","year"],url:"/?i={id}&plot={plot}&tomatoes={tomatoes}&type={type}&y={year}",validator:{plot:"^(short|full)$",tomatoes:"^(true|false)$",type:"^(movie|series|episode)$",year:"^[1|2][0-9]{3}$"}},"/search":{method:"GET",optional:["page","type","year"],url:"/?s={search}&page={page}&type={type}&y={year}",validator:{page:"^[1-9][0-9]*$",type:"^(movie|series|episode)$",year:"^[1|2][0-9]{3}$"}},"/title":{method:"GET",optional:["plot","tomatoes","type","year"],url:"/?t={title}&plot={plot}&tomatoes={tomatoes}&type={type}&y={year}",validator:{plot:"^(short|full)$",tomatoes:"^(true|false)$",type:"^(movie|series|episode)$",year:"^[1|2][0-9]{3}$"}}};return class{constructor(e={},t=e.cache||{}){if(!e.api_key)throw new Error("OMDb API Key is required");this._config={api_key:e.api_key,api_url:e.api_url||"https://www.omdbapi.com",debug:e.debug||!1},this._cache={active:t.active||!1,TTL:1e3*(t.time_to_live||3600)},this._methods()}_this(){return this}_debug(e){this._config.debug&&console.log(`${e.status} - ${e.url}`)}async _crypto(e){const t=await crypto.subtle.digest("SHA-256",(new TextEncoder).encode(e));return[...new Uint8Array(t)].map((e=>e.toString(16).padStart(2,"0"))).join("")}_methods(){for(const t in e){const o=t.split("/"),s=o.pop();o.shift();let r=this._this();for(const e of o)r=r[e]||(r[e]={});r[s]=this._request.bind(this,e[t])}}async _request(e,t){const o=this._resolve(e,t),s=await this._crypto(o).then().catch((e=>new Error(e))),r=JSON.parse(sessionStorage.getItem(s));return new Promise(((t,i)=>{const a=new AbortController,n=setTimeout((()=>{a.abort(),i(new Error("Request times out"))}),15e3);this._cache.active&&r&&Date.now()-r.time<this._cache.TTL?(this._debug({status:"cached",url:o}),t(r.data)):fetch(o,{method:e.method,mode:"cors",signal:a.signal}).then((e=>(clearTimeout(n),this._debug(e),e.json()))).then((e=>{"True"===e.Response?(this._cache.active&&sessionStorage.setItem(s,JSON.stringify({data:e,time:Date.now()})),t(e)):i(new Error(e.Error))})).catch((e=>i(e)))}))}_resolve(e,t){const o=e.url.split("?"),s=t?new Set(Object.keys(t).map((e=>`${e}`))):{},r=[],i=[];if(o[0]&&r.push(o[0]),o[1])for(const r of o[1].split("&")){const o=/{(\w+)}/g.exec(r)[1],a=new RegExp(Object.keys(t).map((e=>`{${e}}`)).join("|"),"gi");if(s.has(o)){for(const s in e.validator)if(Object.hasOwnProperty.call(e.validator,s)&&s===o&&!new RegExp(e.validator[s]).test(t[o]))throw new Error(`Parameter with invalid options => ${o}:${t[o]}`);i.push(r.replace(a,(e=>encodeURIComponent(t[e.replace(/[{}]/g,"")]))))}else if(!e.optional.includes(o))throw new Error(`Missing parameter => ${o}`)}i.push(`apikey=${this._config.api_key}`,"r=json");return`${this._config.api_url}${r.join("/")}${i.length>0?`?${i.join("&")}`:""}`}}}();
